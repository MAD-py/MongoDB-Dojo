# Mongoose (ODM)

Mongoose is an Object Document Mapper (ODM) to manipulate **MongoDB** from Nodejs, with mongoose we will be able to manipulate the connections and the basic configurations of the database.

## Install

To install mongoose you need to have already started a project with npm and execute the following command.

```bash
npm install mongoose
```

## Connect to **MongoDB**

Now to make the connection between our code in Nodejs and **MongoDB** it is necessary to have the following lines of code.

```js
import mongoose from 'mongoose';

await mongoose.connect("mongodb://user:password@127.0.0.1:27017/test");
```

***Note**: in the connection URL it is necessary to change the user, the password and the database to those corresponding to your project.*

## Schemas

In order to use mongoose it is necessary to define the schemas of the entities that we want to use, these schemas are directly related to a collection inside MongoDB and define the types of each field. If you do not know the structure of these entities, you must first read the definition of the practical example that will be solved in this dojo.

```js
import mongoose, { Schema } from 'mongoose';

const courseSchema = new Schema({
    name: String,
    instructor: new Schema({
        name: String,
        email: String,
    }, { _id: false }),
    price: String,
    certifies: Boolean,
});

const userSchema = new Schema({
    name: String,
    last_name: String,
    emails: [new Schema({ email: String, type: String })],
    courses: new Schema({
        completed: [{ type: Schema.Types.ObjectId, ref: "course" }],
        started: [{ type: Schema.Types.ObjectId, ref: "course" }],
    }),
});

const Course = mongoose.model("Course", courseSchema, "course");
const User = mongoose.model("User", userSchema, "user");
```

Something to highlight in the user schemas are the courses.completed and courses.started fields, since these fields are arrays of ObjectIds that are basically nothing more than references to the collection of courses by means of an id.

## CRUD

We will start by creating the crud for the Course entity. Note that you must first have the connection and schemas from the previous section ready.

## Create Courses

To create a single course we can use the following lines of code:

```js
let newDocument = new Course({
    name: "Cloud Computing I",
    instructor: {
        "name": "Jose Gomez Gomez",
        "email": "josegg@gmail.com"
    },
    price: "$45.78",
    certifies: false,
});
let documentInDB = await newDocument.save();
console.log(documentInDB.toObject());
```

With these lines we have created a document in the "course" collection, to this document the "_id" field is autogenerated, which is the one that will identify it within the collection. To create several courses in a single operation we can use.

```js
const arr = [
    {
        name: "Cloud Computing II",
        instructor: {
            "name": "Jose Gomez Gomez",
            "email": "josegg@gmail.com",
        },
        price: "$50.78",
        certifies: true,
    },
    {
        name: "Cloud Computing III",
        instructor: {
            "name": "Jose Gomez Gomez",
            "email": "josegg@gmail.com",
        },
        co_instructor: {
            "name": "Juan Zapata Gomez",
            "email": "jzg@gmail.com",
        },
        price: "$38.00",
        certifies: true,
    },
    {
        name: "Introduction to deep learning",
        instructor: {
            "name": "John Agudelo Gomez",
            "email": "jagudelo@gmail.com",
        },
        price: "$90.84",
        certifies: false,
    },
];
let documentsInDB = await Course.insertMany(arr);
console.log(documentsInDB);
```

With everything we have done so far we have created 4 courses in our database.

## Read Courses

To get all the courses we can use the following line of code:

```js
let documents = await Course.find({}).exec();
console.log(documents);
```

This function returns all documents within the collection "course" as we do not use any filter, if you want to filter the courses you can do so by adding filters within the dictionary.

```js
let documents = await Course.find({ certifies: true }).exec();
console.log(documents);
```

With this modification we will only get the courses that have certificates, in **MongoDB** there are multiple operators to make filters as complex as we want, if you are interested in knowing more about the operators that **MongoDB** offers you can consult them in the following [link](https://www.mongodb.com/docs/manual/reference/operator/query/).

## Update Courses

To update a single document we can use the following lines of code:

```js
let updateDocument = await Course
    .findOneAndUpdate(
        { name: "Cloud Computing II" },
        { $set: {price: "$60.90"} },
    )
    .exec();
console.log(updateDocument.toObject());
```

With this code we have updated the value of the course that has the name "Cloud Computing II" to "$60.90" dollars, the findOneAndUpdate method will only update the first document it finds with this name regardless of whether the filter used returns more documents, if you want to update all documents that meet the filter we must do it with the following method.

```js
let updateDocument = await Course
    .updateMany(
        { "instructor.name": "Jose Gomez Gomez" },
        { $set: { certifies: true } },
    )
    .exec();
console.log(updateDocument);
```

With this operation we have updated all the courses of the instructor "Jose Gomez Gomez", it is necessary to clarify that if any course of the instructor already had the certified value in true, this operation will overwrite it with the same value.

***Note:** The `$set` operator in the examples indicates the values to be updated in the documents.*

## Delete Courses:

To delete a single document we can use the following line of code:

```js
await Course.findOneAndDelete({ name: "Introduction to deep learning" });
```

With this we have removed the "Introduction to deep learning" course from our course collection, as in the updates this method will only remove the first document and if we want to remove all the documents that meet our filter we can use the following.

```js
await Course.deleteMany({ certifies: true });
```

After this operation our "course" collection should be empty.

***Note:** To continue with the Dojo it is necessary to recreate all the courses, it is recommended to rerun the two code snippets exposed in the Dojo to create new documents in a collection.*

Now that we know how to use the basic operations it is time to test how the relations work inside **MongoDB**, for this now we will create a new user and we will obtain the created document.

## Create Users

To create a user we will use the same method we used for the courses. In order to execute this part it is necessary to replace the 'course_id' with some valid id from the 'course' collection.

```js
let newDocument = new User({
    name: "Emanuel",
    last_name: "Rojas Moreno",
    emails: [
        {
            "email": "emanuel.rojas@gmail.com",
            "type": "academic"
        },
        {
            "email": "ema123@gmail.com",
            "type": "personal"
        }
    ],
    courses: {
        "completed": [course_id,  course_id],
        "started": [course_id],
    },
});
let documentInDB = await newDocument.save();
console.log(documentInDB.toObject());
```

As in the definition of the schemas it was indicated that the courses.completed and courses.started fields are of type ObjectID with reference to the courses, mongoose directly transforms the strings that we pass to referenced ids. It should be noted that these relations do not work as in the sql database, since if the id that we put as relation does not exist in any **MongoDB** collection, it will not generate any type of error.

## Read Users

Now, if we get all the users we will see that it will only show us the ids of the courses and not the complete object.

```js
let documents = await User.find({}).exec();
console.log(documents);
```

If we want the relations to be resolved it is necessary to tell **MongoDB** to do it, this can be done with the following code.

```js
let documents = await User.aggregate([
    {
        $lookup: {
            from: "course",
            localField: "courses.completed",
            foreignField: "_id",
            as: "courses.completed"
        }
    },
    {
        $lookup: {
            from: "course",
            localField: "courses.started",
            foreignField: "_id",
            as: "courses.started"
        }
    }
])
console.log(documents);
```

We can notice that we no longer use the find method to obtain the documents of a collection, instead we use the aggregate method, this method allows us to create a pipeline of operations on a collection. In this case we are instructing it to perform two lookup operations to resolve the relationships of the completed and started courses.

The result of this is the same as executing the find method but this time we will get a list of objects that are the user's courses, instead of a list of just ids.

These are the most basic operations that can be performed on a collection, but within **MongoDB** there are many other operations, in case you want to continue learning about **MongoDB** and mongoose I invite you to visit the official [website](https://mongoosejs.com/docs/guides.html) of mongoose.
